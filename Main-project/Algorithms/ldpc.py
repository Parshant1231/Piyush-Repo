import numpy as np

# ----- Utility functions for LDPC -----
def generate_ldpc_matrix(n, m, density=0.1):
    """
    Generates a random LDPC parity-check matrix.
    :param n: number of columns (codeword length).
    :param m: number of rows (number of parity-check equations).
    :param density: probability of a 1 in the matrix.
    :return: A binary LDPC parity-check matrix (m x n).
    """
    matrix = np.random.rand(m, n) < density
    return matrix.astype(int)

def print_ldpc_matrix(H):
    """
    Prints the LDPC parity-check matrix.
    :param H: Parity-check matrix.
    """
    print("LDPC Parity-Check Matrix:")
    print(H)

def bit_flip(value):
    """
    Flip a bit from 0 to 1 or 1 to 0.
    :param value: The bit to flip.
    :return: Flipped bit.
    """
    return 1 - value

def apply_bitflip_to_codeword(codeword, indices):
    """
    Applies bit flips to the given codeword at specified indices.
    :param codeword: List or numpy array representing the codeword.
    :param indices: List of indices to flip.
    :return: The modified codeword.
    """
    for index in indices:
        codeword[index] = bit_flip(codeword[index])
    return codeword

def get_syndrome(H, codeword):
    """
    Computes the syndrome vector from the parity-check matrix H and the codeword.
    :param H: Parity-check matrix.
    :param codeword: Codeword to check.
    :return: Syndrome vector.
    """
    return np.mod(np.dot(H, codeword), 2)

# ----- LDPC Encoding -----
def encode_ldpc(H, message):
    """
    Encode a message using the LDPC encoding process.
    :param H: Parity-check matrix.
    :param message: Message to encode (binary).
    :return: Encoded codeword.
    """
    n = H.shape[1]
    m = H.shape[0]
    codeword = np.zeros(n, dtype=int)
    codeword[:len(message)] = message

    # Further encoding logic would go here, like matrix manipulations and redundant bits insertion.
    # This is a simple placeholder encoding; LDPC usually involves more complex encoding.
    
    return codeword

# ----- LDPC Decoding (Belief Propagation) -----
def initialize_belief_propagation(H, codeword):
    """
    Initialize the message passing process.
    :param H: Parity-check matrix.
    :param codeword: Received codeword with possible errors.
    :return: Initialized message passing structure.
    """
    m, n = H.shape
    # Initialize message passing variables (typically beliefs or probabilities).
    # Placeholder: will initialize as ones or zeros depending on error model.
    return np.zeros((m, n), dtype=int)

def belief_propagation_step(H, messages):
    """
    Perform a single step of belief propagation.
    :param H: Parity-check matrix.
    :param messages: Current message passing state.
    :return: Updated message passing state.
    """
    # Here we would perform the message passing logic:
    # - Check message consistency.
    # - Perform updates based on parity-check relations.
    return messages

def decode_ldpc(H, received_codeword, max_iterations=50):
    """
    Decode a codeword using LDPC and belief propagation.
    :param H: Parity-check matrix.
    :param received_codeword: Received codeword with possible errors.
    :param max_iterations: Max iterations to try decoding.
    :return: Decoded codeword or None if failure.
    """
    syndrome = get_syndrome(H, received_codeword)
    if np.sum(syndrome) == 0:
        # No error detected
        return received_codeword

    # Initialize belief propagation process
    messages = initialize_belief_propagation(H, received_codeword)
    
    for iteration in range(max_iterations):
        messages = belief_propagation_step(H, messages)
        decoded_codeword = messages_to_codeword(messages)
        syndrome = get_syndrome(H, decoded_codeword)
        
        if np.sum(syndrome) == 0:
            print(f"Decoding successful after {iteration + 1} iterations.")
            return decoded_codeword
    
    print("Decoding failed after max iterations.")
    return None

# ----- Helper Functions for Error Correction -----
def messages_to_codeword(messages):
    """
    Convert the messages passed during belief propagation back into a codeword.
    :param messages: Messages generated by belief propagation.
    :return: The corresponding codeword.
    """
    return np.mod(np.sum(messages, axis=0), 2)

def correct_codeword_using_ldpc(H, received_codeword, max_iterations=50):
    """
    Corrects errors in a received codeword using LDPC decoding.
    :param H: Parity-check matrix.
    :param received_codeword: Codeword that may contain errors.
    :param max_iterations: Max number of iterations before declaring failure.
    :return: Corrected codeword or None if unable to correct.
    """
    decoded_codeword = decode_ldpc(H, received_codeword, max_iterations)
    return decoded_codeword

# ----- Error Injection and Testing -----
def inject_error_to_codeword(codeword, error_rate=0.1):
    """
    Inject errors into a codeword at a specified rate.
    :param codeword: Original codeword.
    :param error_rate: The probability of flipping each bit in the codeword.
    :return: Codeword with errors injected.
    """
    error_codeword = np.copy(codeword)
    n = len(codeword)
    
    for i in range(n):
        if random.random() < error_rate:
            error_codeword[i] = bit_flip(error_codeword[i])
    
    return error_codeword

# ----- LDPC Testing -----
def test_ldpc():
    # Generate random LDPC matrix (7x3 example)
    H = generate_ldpc_matrix(7, 3)
    
    # Example message to encode
    message = np.array([1, 0, 1])
    
    # Encode message
    encoded_codeword = encode_ldpc(H, message)
    print("Encoded Codeword: ", encoded_codeword)

    # Inject errors
    received_codeword = inject_error_to_codeword(encoded_codeword, error_rate=0.25)
    print("Received Codeword with Errors: ", received_codeword)

    # Correct errors using LDPC
    corrected_codeword = correct_codeword_using_ldpc(H, received_codeword)
    print("Corrected Codeword: ", corrected_codeword)

test_ldpc()

