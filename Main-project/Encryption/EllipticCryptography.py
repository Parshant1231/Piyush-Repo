import random

class ECC:
    def __init__(self, a, b, p, G, n):
        """
        Initialize the Elliptic Curve parameters:
     
        :param G: Base point (generator)
        :param n: Order of the group generated by G
        """
        self.a = a
        self.b = b
        self.p = p
        self.G = G
        self.n = n

    def is_on_curve(self, x, y):
        """Check if a point (x, y) lies on the curve."""
        return (y ** 2 - (x ** 3 + self.a * x + self.b)) % self.p == 0

    def point_addition(self, P, Q):
        """Add two points P and Q on the curve."""
        if P == "O": return Q
        if Q == "O": return P

        x1, y1 = P
        x2, y2 = Q

        if x1 == x2 and y1 != y2:
            return "O"

        if x1 == x2:
            m = (3 * x1**2 + self.a) * pow(2 * y1, -1, self.p) % self.p
        else:
            m = (y2 - y1) * pow(x2 - x1, -1, self.p) % self.p

        x3 = (m**2 - x1 - x2) % self.p
        y3 = (m * (x1 - x3) - y1) % self.p
        return (x3, y3)

    def scalar_multiplication(self, k, P):
        """Multiply a point P by an integer k."""
        R = "O"
        Q = P
        while k:
            if k & 1:
                R = self.point_addition(R, Q)
            Q = self.point_addition(Q, Q)
            k >>= 1
        return R

    def generate_key_pair(self):
        """Generate a private-public key pair."""
        private_key = random.randint(1, self.n - 1)
        public_key = self.scalar_multiplication(private_key, self.G)
        return private_key, public_key

    def encrypt(self, plaintext, public_key):
        """Encrypt a message using ECC."""
        k = random.randint(1, self.n - 1)
        R = self.scalar_multiplication(k, self.G)
        S = self.scalar_multiplication(k, public_key)
        ciphertext = (R, (plaintext * S[0]) % self.p)
        return ciphertext

    def decrypt(self, ciphertext, private_key):
        """Decrypt a message using ECC."""
        R, enc_message = ciphertext
        S = self.scalar_multiplication(private_key, R)
        S_inv = pow(S[0], -1, self.p)
        plaintext = (enc_message * S_inv) % self.p
        return plaintext

    def sign(self, message, private_key):
        """Create a digital signature for a message."""
        k = random.randint(1, self.n - 1)
        R = self.scalar_multiplication(k, self.G)
        r = R[0] % self.n
        s = (pow(k, -1, self.n) * (message + private_key * r)) % self.n
        return (r, s)

    def verify(self, message, signature, public_key):
        """Verify a digital signature."""
        r, s = signature
        w = pow(s, -1, self.n)
        u1 = (message * w) % self.n
        u2 = (r * w) % self.n
        X = self.point_addition(
            self.scalar_multiplication(u1, self.G),
            self.scalar_multiplication(u2, public_key)
        )
        return X[0] % self.n == r



if __name__ == "__main__":
    # Curve parameters for secp256k1
    a, b, p = 0, 7, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
    G = (55066263022277343669578718895168534326250603453777594175500187360389116729240,
         32670510020758816978083085130507043184471273380659243275938904335757337470005)
    n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

    ecc = ECC(a, b, p, G, n)

    # Generate key pair
    private_key, public_key = ecc.generate_key_pair()
    print(f"Private Key: {private_key}")
    print(f"Public Key: {public_key}")

    # Encrypt and Decrypt
    plaintext = 12345
    ciphertext = ecc.encrypt(plaintext, public_key)
    print(f"Ciphertext: {ciphertext}")
    decrypted_message = ecc.decrypt(ciphertext, private_key)
    print(f"Decrypted Message: {decrypted_message}")

    # Digital Signature
    message = 67890
    signature = ecc.sign(message, private_key)
    print(f"Signature: {signature}")
    is_valid = ecc.verify(message, signature, public_key)
    print(f"Signature Valid: {is_valid}")
